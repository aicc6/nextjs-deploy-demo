pipeline {
    // Jenkins가 실행할 에이전트 지정 (any = 사용 가능한 모든 에이전트에서 실행)
    agent any

    triggers {
        // GitHub에서 Push 이벤트가 발생하면 자동으로 빌드 시작
        githubPush()
    }

    tools {
        // Jenkins Global Tool Configuration에서 설정한 Node.js 버전
        // Jenkins 관리 > Global Tool Configuration > NodeJS에서 'node-v22.18.0' 이름으로 설정 필요
        nodejs 'node-v22.18.0'
    }

    environment {
        // Jenkins Credentials에서 관리할 환경 변수들
        NODE_ENV = 'production'  // Node.js 실행 환경 설정 (production/development/staging)

        // 배포 경로 정보
        DEPLOY_PATH = '/var/www/nextjs-deploy-demo'  // 원격 서버의 애플리케이션 설치 경로
        APP_NAME = 'nextjs-deploy-demo'              // PM2에서 사용할 애플리케이션 이름
        APP_PORT = '9000'                            // 애플리케이션이 실행될 포트 번호
    }

    stages {
        stage('Checkout') {
            steps {
                // Git 저장소에서 소스 코드를 체크아웃 (SCM = Source Control Management)
                checkout scm
                // 현재 빌드 중인 브랜치 이름 출력
                echo "Branch: ${env.GIT_BRANCH}"
                // 현재 빌드 중인 커밋 해시 출력
                echo "Commit: ${env.GIT_COMMIT}"
            }
        }

        stage('Install Dependencies') {
            steps {
                script {
                    sh '''
                        # Node.js와 NPM 버전 확인 (디버깅용)
                        echo "Node version: $(node -v)"
                        echo "NPM version: $(npm -v)"
                        echo "Current NODE_ENV: $NODE_ENV"

                        # 이전 빌드의 잔재 제거 (클린 빌드 보장)
                        echo "Cleaning previous installations..."
                        rm -rf node_modules .next  # node_modules와 .next 빌드 폴더 삭제

                        # 모든 의존성 설치 (devDependencies 포함)
                        # npm ci: package-lock.json 기반 정확한 버전 설치 (npm install보다 빠르고 안정적)
                        # --include=dev: production 환경에서도 devDependencies 설치 (빌드에 필요)
                        echo "Installing dependencies (including devDependencies)..."
                        npm ci --include=dev

                        # TypeScript 설치 확인 (Next.js 빌드에 필수)
                        echo "Verifying TypeScript installation..."
                        if [ -f "node_modules/.bin/tsc" ]; then
                            echo "TypeScript is installed"
                            ./node_modules/.bin/tsc --version  # TypeScript 버전 출력
                        else
                            echo "ERROR: TypeScript not found after installation"
                            exit 1  # TypeScript가 없으면 빌드 실패 처리
                        fi
                    '''
                }
            }
        }

        stage('Code Quality') {
            // 코드 품질 검사를 병렬로 실행하여 시간 단축
            parallel {
                stage('Lint') {
                    steps {
                        // ESLint 실행 - 코드 스타일과 잠재적 오류 검사
                        sh 'npm run lint'
                    }
                }
                stage('Type Check') {
                    steps {
                        sh '''
                            echo "Running TypeScript type check..."
                            # TypeScript 타입 검사 실행
                            # --noEmit: 실제 파일을 생성하지 않고 타입 체크만 수행
                            ./node_modules/.bin/tsc --noEmit
                        '''
                    }
                }
            }
        }

        stage('Build') {
            steps {
                script {
                    sh '''
                        echo "Building Next.js application..."
                        # 이전 빌드 아티팩트 제거 (클린 빌드)
                        rm -rf .next

                        # Next.js 프로덕션 빌드 실행
                        # NODE_ENV=production: 프로덕션 최적화 활성화 (코드 압축, 트리 쉐이킹 등)
                        NODE_ENV=production npm run build

                        echo "Build completed successfully"
                    '''
                }
            }
        }

        stage('Test') {
            steps {
                script {
                    sh '''
                        echo "Running tests..."
                        # 테스트 스크립트가 있다면 실행 (현재는 주석 처리됨)
                        # npm test
                        echo "Tests completed"
                    '''
                }
            }
        }

        stage('Prepare Deployment') {
            steps {
                script {
                    // 배포 패키지 준비
                    sh '''
                        echo "Preparing deployment package..."

                        # 배포 패키지 생성 (필요한 파일만 압축)
                        # tar -czf: c(생성) z(gzip 압축) f(파일명 지정)
                        tar -czf ${APP_NAME}.tar.gz \
                            .next \
                            public \
                            package.json \
                            package-lock.json \
                            ecosystem.config.js \
                            scripts/

                        echo "Deployment package created"
                    '''
                }
            }
        }

        stage('Deploy to Production') {
            steps {
                script {
                    // 브랜치 정보 출력 (디버깅용)
                    echo "Current branch: ${env.BRANCH_NAME}"
                    echo "GIT_BRANCH: ${env.GIT_BRANCH}"

                    // main 브랜치인 경우에만 프로덕션 배포 실행
                    // GIT_BRANCH는 'origin/main', 'main', 또는 'refs/heads/main' 형태일 수 있음
                    if (env.GIT_BRANCH == 'origin/main' || env.GIT_BRANCH == 'main' || env.GIT_BRANCH?.endsWith('/main')) {
                        echo "Deploying to production automatically..."
                        deployToServer('production')
                    } else {
                        echo "Skipping deployment - not on main branch (current: ${env.GIT_BRANCH})"
                    }
                }
            }
        }

    }

    post {
        // 파이프라인 실행 완료 후 수행할 작업 정의
        success {
            echo 'Pipeline completed successfully!'
            // 성공 시 Slack 또는 이메일 알림 (현재 주석 처리)
            // slackSend(color: 'good', message: "Deployment successful: ${env.JOB_NAME} - ${env.BUILD_NUMBER}")
        }
        failure {
            echo 'Pipeline failed!'
            // 실패 시 Slack 또는 이메일 알림 (현재 주석 처리)
            // slackSend(color: 'danger', message: "Deployment failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}")
        }
    }
}

// 서버 배포 함수 정의
def deployToServer(String environment) {
    // 배포 경로 변수 설정
    def deployPath = "${DEPLOY_PATH}"

    // Jenkins Credentials에 저장된 배포 서버 정보 로드
    // credentialsId: Jenkins에서 설정한 자격 증명 ID
    // variable: 스크립트에서 사용할 변수명
    withCredentials([
        string(credentialsId: 'deploy-server-host', variable: 'DEPLOY_SERVER'),  // 배포 서버 호스트명/IP
        string(credentialsId: 'deploy-server-user', variable: 'DEPLOY_USER')      // SSH 접속 사용자명
    ]) {
        // 디버깅을 위한 상세 정보 출력
        sh '''#!/bin/bash
            echo "=== Credential Debug Info ==="

            # DEPLOY_SERVER 변수 유효성 검사
            if [ -z "$DEPLOY_SERVER" ]; then  # -z: 문자열 길이가 0인지 확인
                echo "ERROR: DEPLOY_SERVER is empty or not set!"
                echo "Please check Jenkins Credentials configuration"
                exit 1  # 변수가 없으면 빌드 실패
            else
                echo "DEPLOY_SERVER is set (value hidden for security)"
                # 보안을 위해 전체 값 대신 첫 글자와 길이만 출력
                echo "Server starts with: $(echo $DEPLOY_SERVER | cut -c1)"  # 첫 글자만 표시
                echo "Server length: $(echo -n $DEPLOY_SERVER | wc -c)"       # 문자열 길이 표시
            fi

            # DEPLOY_USER 변수 유효성 검사
            if [ -z "$DEPLOY_USER" ]; then  # -z: 문자열 길이가 0인지 확인
                echo "ERROR: DEPLOY_USER is empty or not set!"
                echo "Please check Jenkins Credentials configuration"
                exit 1  # 변수가 없으면 빌드 실패
            else
                echo "DEPLOY_USER is set (value hidden for security)"
                # 보안을 위해 전체 값 대신 첫 글자와 길이만 출력
                echo "User starts with: $(echo $DEPLOY_USER | cut -c1)"  # 첫 글자만 표시
                echo "User length: $(echo -n $DEPLOY_USER | wc -c)"       # 문자열 길이 표시
            fi

            echo "Variables are configured, proceeding..."
        '''

        // SSH 에이전트를 사용한 안전한 SSH 연결 설정
        // 'aicc': Jenkins에 등록된 SSH Private Key의 ID
        sshagent(credentials: ['aicc']) {
            sh """
                echo "Deploying to ${environment} server..."

                # 직접 변수 사용 테스트
                echo "Testing connection to: \${DEPLOY_USER}@\${DEPLOY_SERVER}"

                # 원격 서버에 배포 디렉토리 생성
                # -o StrictHostKeyChecking=no: 처음 연결 시 호스트 키 확인 프롬프트 건너뛰기
                # mkdir -p: 부모 디렉토리까지 재귀적으로 생성, 이미 존재해도 오류 없음
                ssh -o StrictHostKeyChecking=no \${DEPLOY_USER}@\${DEPLOY_SERVER} "mkdir -p ${deployPath}/releases/${BUILD_NUMBER}"

                # 압축된 배포 패키지를 원격 서버로 전송
                # scp: SSH를 통한 안전한 파일 복사
                scp ${APP_NAME}.tar.gz \${DEPLOY_USER}@\${DEPLOY_SERVER}:${deployPath}/releases/${BUILD_NUMBER}/

                # 원격 서버에서 배포 스크립트 실행
                # << 'ENDSSH': Here Document 시작 (ENDSSH까지의 내용을 원격 서버에서 실행)
                ssh \${DEPLOY_USER}@\${DEPLOY_SERVER} << 'ENDSSH'
                set -e  # 오류 발생 시 즉시 스크립트 종료

                # NVM (Node Version Manager) 환경 설정 로드
                export NVM_DIR="\$HOME/.nvm"  # NVM 설치 디렉토리 설정
                [ -s "\$NVM_DIR/nvm.sh" ] && . "\$NVM_DIR/nvm.sh"  # NVM 스크립트 로드 (파일이 존재하면)
                [ -s "\$NVM_DIR/bash_completion" ] && . "\$NVM_DIR/bash_completion"  # 자동 완성 기능 로드

                # Node.js 버전 설정 (순차적으로 시도)
                # default 버전 사용 → 실패 시 node 별칭 → 실패 시 stable 버전
                nvm use default || nvm use node || nvm use stable

                echo "Node version: \$(node -v)"
                echo "NPM version: \$(npm -v)"

                cd ${deployPath}/releases/${BUILD_NUMBER}

                # 배포 패키지 압축 해제
                tar -xzf ${APP_NAME}.tar.gz  # x(추출) z(gzip) f(파일)
                rm ${APP_NAME}.tar.gz         # 압축 파일 삭제 (공간 절약)

                # 프로덕션 환경 변수 파일 생성
                # cat > .env.production: 파일 생성 및 내용 작성
                # << EOF: Here Document로 여러 줄 입력
                cat > .env.production << EOF
NODE_ENV=production  # Node.js 실행 환경을 프로덕션으로 설정
EOF

                echo "Environment variables configured:"
                echo "-----------------------------------"
                echo "NODE_ENV=production"
                echo "-----------------------------------"

                # 프로덕션 의존성만 설치
                # npm ci: package-lock.json 기반 정확한 버전 설치
                # --omit=dev: devDependencies 제외 (프로덕션에 불필요)
                # --no-audit: 보안 감사 건너뛰기 (배포 속도 향상)
                npm ci --omit=dev --no-audit

                # 이전 버전 백업 (롤백 대비)
                # -L: 심볼릭 링크인지 확인
                if [ -L ${deployPath}/current ]; then
                    rm ${deployPath}/previous 2>/dev/null || true  # 기존 previous 삭제 (오류 무시)
                    mv ${deployPath}/current ${deployPath}/previous  # current를 previous로 이동
                fi

                # 심볼릭 링크 업데이트 (무중단 배포)
                # ln -sfn: s(심볼릭 링크) f(강제 덮어쓰기) n(심볼릭 링크를 일반 파일처럼 취급)
                ln -sfn ${deployPath}/releases/${BUILD_NUMBER} ${deployPath}/current

                # PM2로 애플리케이션 재시작
                cd ${deployPath}/current

                # PM2 (Node.js 프로세스 매니저) 설치 확인
                # command -v: 명령어 존재 여부 확인
                # &> /dev/null: 출력 숨기기
                if ! command -v pm2 &> /dev/null; then
                    echo "PM2 not found, installing globally..."
                    npm install -g pm2  # 전역 설치
                fi

                # PM2 홈 디렉토리 설정 (로그 폴더 권한 문제 해결)
                export PM2_HOME="\$HOME/.pm2"  # 사용자 홈에 PM2 데이터 저장

                # PM2로 애플리케이션 실행/재시작
                # reload: 무중단 재시작 (실행 중이면) || start: 새로 시작 (실행 중이 아니면)
                # --env: ecosystem.config.js의 환경 설정 사용
                pm2 reload ecosystem.config.js --env ${environment} || pm2 start ecosystem.config.js --env ${environment}

                # PM2 상태 확인
                pm2 list  # 실행 중인 프로세스 목록 표시
                # 최근 5줄의 로그 출력 (스트리밍 없이)
                pm2 logs ${APP_NAME} --lines 5 --nostream || echo "Logs not available yet"

                # 오래된 릴리즈 정리 (디스크 공간 관리)
                cd ${deployPath}/releases
                # ls -t: 시간순 정렬 | tail -n +6: 6번째부터 출력 (최근 5개 제외)
                # xargs -I {}: 각 항목에 대해 rm -rf 실행
                ls -t | tail -n +6 | xargs -I {} rm -rf {}

                    echo "Deployment to ${environment} completed!"
ENDSSH
            """
        }
    }
}